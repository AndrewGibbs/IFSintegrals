# -------------- functions for affine operators on fractals --------------- #

# following function embeds similarity in equivalent one in higher/ambeint dimension
function embed(s::Similarity{V,M}, v::Vector{Float64}
            ) where {V<:Union{Real,AbstractVector}, M<:Union{Real,AbstractMatrix}}
    if s.A == I
        A_ = I
        rA_ = s.r*I
    else
        n = length(s.δ)
        n_ = n + length(v)
        A_ = I[1:n_,1:n_]
        A_[1:n,1:n] = s.A
        rA_ = s.r*I[1:n_,1:n_]
        rA_[1:n,1:n] = s.rA

    end
    return Similarity(s.r,vcat(s.δ,v),A_,rA_)
end

function embed(AM::AutomorphicMap{V,M}, v::Vector{Float64}
                ) where {V<:Union{Real,AbstractVector}, M<:Union{Real,AbstractMatrix}}
    n = length(s.δ)
    n_ = n + length(v)
    A_ = I[1:n_,1:n_]
    A_[1:n,1:n] = AM.A
    return AutomorphicMap(AM.r,vcat(AM.δ,v))
end

function embed(Γ::InvariantMeasure{V,M}, v::Vector{Float64}
        ) where {V<:Union{Real,AbstractVector}, M<:Union{Real,AbstractMatrix}}
    return InvariantMeasure{V,M}(
        [embed(sₘ,v) for sₘ ∈ Γ.IFS], # embedded IFS
        Γ.spatial_dimension + length(v),
        Γ.Hausdorff_dimension,
        Γ.homogeneous,
        Γ.Hausdorff_weights,
        vcat(Γ.barycentre,v),
        Γ.diameter,
        Γ.measure,
        Γ.weights,
        Γ.disjoint,
        Γ.connectedness,
        [embed(T,v) for T ∈ Γ.symmetry_group]
    )
end

# ------------------- addition / translation of fractals ----------------------

# following function translates fractal attractor
function +(s::Similarity, v::Vector{Float64})# where {V<:Union{Real,AbstractVector}, M<:Union{Real,AbstractMatrix}}
    # if length(s.δ)<length(v)
    #     s = embed(s,zeros(length(v)))
    # end
    return Similarity(s.r, # scale (same)
                    -s.rA*v+s.δ+v, # translation 
                    s.A, # rotation/reflection (same)
                    s.rA) # scale*rotation/reflection (same)
end

+(AM::AutomorphicMap, v::Vector{Float64}) = AutomorphicMap(AM.A,AM.δ+v)

function +(Γ::InvariantMeasure{V,M}, v::Vector{Float64}
            ) where {V<:Union{Real,AbstractVector}, M<:Union{Real,AbstractMatrix}}
            # make sure vector is right length, if not, mbed it in higher dimenson
            if Γ.spatial_dimension < length(v)
                Γ = embed(Γ,zeros(length(v)))
            elseif Γ.spatial_dimension > length(v)
                error("Spatial dimension of translation is lower than that of fractal.")
            end

            return InvariantMeasure(
                [sₘ+v for sₘ ∈ Γ.IFS], # translated IFS
                length(v),
                Γ.Hausdorff_dimension,
                Γ.homogeneous,
                Γ.Hausdorff_weights,
                vcat(Γ.barycentre,v), # higher spatial dimension
                Γ.diameter,
                Γ.measure,
                Γ.weights,
                Γ.disjoint,
                Γ.connectedness,
                [T+v for T ∈ Γ.symmetry_group] # translated symmetry_group
            )
end

# sort out commutation & subtraction
+(v::Vector{Float64},s::Union{Similarity,AutomorphicMap, InvariantMeasure}) = +(s, v)
-(s::Union{Similarity,AutomorphicMap, InvariantMeasure}, v::Vector{Float64}) = +(s, -v)

# ------------- streching fractals ------------ #

function *(s::Similarity, ρ::Float64)# where {V<:Union{Real,AbstractVector}, M<:Union{Real,AbstractMatrix}}
    return Similarity(s.r, # scale (same)
                    ρ*s.δ, # translation 
                    s.A, # rotation/reflection (same)
                    s.rA) # scale*rotation/reflection (same)
end

*(AM::AutomorphicMap, ρ::Float64) = AutomorphicMap(AM.A,AM.δ*ρ)

function *(Γ::InvariantMeasure{V,M}, ρ::Float64,
    ) where {V<:Union{Real,AbstractVector}, M<:Union{Real,AbstractMatrix}}
    # make sure vector is right length, if not, mbed it in higher dimenson

    return InvariantMeasure(
        [sₘ*ρ for sₘ ∈ Γ.IFS], # translated IFS
        Γ.spatial_dimension,
        Γ.Hausdorff_dimension,
        Γ.homogeneous,
        Γ.Hausdorff_weights,
        Γ.barycentre*ρ,
        Γ.diameter*ρ,
        Γ.measure, # CONTENTIOUS ISSUE - leaving this unchanged
        Γ.weights,
        Γ.disjoint,
        Γ.connectedness,
        [T*ρ for T ∈ Γ.symmetry_group] # translated symmetry_group
    )
end

# communtes:
*(ρ::Float64, Γ::InvariantMeasure{V,M}) = *(Γ, ρ)

# ------------- rotating / reflecting fractals ------------ #

function *(T::Matrix{<:Real}, s::Similarity)
    if det(T) ≈ 1
        return Similarity(s.r, # scale (same)
            T*s.δ, # translation 
            T*s.A*inv(T), # rotation/reflection (same)
            T*s.rA*inv(T)) # scale*rotation/reflection (same)
    else
        error("rotation/reflection matrix needs to have determinant one")
    end
end

function *(T::Matrix{<:Real}, AM::AutomorphicMap)
    if det(T) ≈ 1
        return AutomorphicMap(
            T*AM.A*inv(T), # rotation/reflection (same)
            T*AM.δ, # translation
        )
    else
        error("rotation/reflection matrix needs to have determinant one")
    end
end

function *(Γ::InvariantMeasure{V,M}, R::Matrix{<:Real},
    ) where {V<:Union{Real,AbstractVector}, M<:Union{Real,AbstractMatrix}}
    # make sure vector is right length, if not, mbed it in higher dimenson
    if !(det(R) ≈ 1)
        ρ = det(R)^(1/size(R)[1])
        Γ = ρ*Γ
        R = R/ρ
    end
    # up to here
    return InvariantMeasure(
        [R*sₘ for sₘ ∈ Γ.IFS], # translated IFS
        Γ.spatial_dimension,
        Γ.Hausdorff_dimension,
        Γ.homogeneous,
        Γ.Hausdorff_weights,
        Γ.barycentre,
        Γ.diameter,
        Γ.measure, # CONTENTIOUS ISSUE - leaving this unchanged
        Γ.weights,
        Γ.disjoint,
        Γ.connectedness,
        [R*T for T ∈ Γ.symmetry_group] # translated symmetry_group
    )
end